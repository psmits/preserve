// Code generated by Stan version 2.5

#include <stan/model/model_header.hpp>
#include <stan/common/command.hpp>

namespace fauna_surv_model_model_namespace {

using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::prob_grad;
using namespace stan::math;
using namespace stan::prob;

typedef Eigen::Matrix<double,Eigen::Dynamic,1> vector_d;
typedef Eigen::Matrix<double,1,Eigen::Dynamic> row_vector_d;
typedef Eigen::Matrix<double,Eigen::Dynamic,Eigen::Dynamic> matrix_d;

class fauna_surv_model_model : public prob_grad {
private:
    int N;
    int O;
    int R;
    int C;
    int F;
    int N_unc;
    int N_cen;
    vector<int> samp_unc;
    vector<int> samp_cen;
    vector<double> dur_unc;
    vector<int> group_unc;
    vector<int> cohort_unc;
    vector<double> dur_cen;
    vector<int> group_cen;
    vector<int> cohort_cen;
    vector<int> regime;
    vector<int> fauna;
public:
    fauna_surv_model_model(stan::io::var_context& context__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        static const char* function__ = "fauna_surv_model_model_namespace::fauna_surv_model_model(%1%)";
        (void) function__; // dummy call to supress warning
        size_t pos__;
        (void) pos__; // dummy call to supress warning
        std::vector<int> vals_i__;
        std::vector<double> vals_r__;
        context__.validate_dims("data initialization", "N", "int", context__.to_vec());
        N = int(0);
        vals_i__ = context__.vals_i("N");
        pos__ = 0;
        N = vals_i__[pos__++];
        context__.validate_dims("data initialization", "O", "int", context__.to_vec());
        O = int(0);
        vals_i__ = context__.vals_i("O");
        pos__ = 0;
        O = vals_i__[pos__++];
        context__.validate_dims("data initialization", "R", "int", context__.to_vec());
        R = int(0);
        vals_i__ = context__.vals_i("R");
        pos__ = 0;
        R = vals_i__[pos__++];
        context__.validate_dims("data initialization", "C", "int", context__.to_vec());
        C = int(0);
        vals_i__ = context__.vals_i("C");
        pos__ = 0;
        C = vals_i__[pos__++];
        context__.validate_dims("data initialization", "F", "int", context__.to_vec());
        F = int(0);
        vals_i__ = context__.vals_i("F");
        pos__ = 0;
        F = vals_i__[pos__++];
        context__.validate_dims("data initialization", "N_unc", "int", context__.to_vec());
        N_unc = int(0);
        vals_i__ = context__.vals_i("N_unc");
        pos__ = 0;
        N_unc = vals_i__[pos__++];
        context__.validate_dims("data initialization", "N_cen", "int", context__.to_vec());
        N_cen = int(0);
        vals_i__ = context__.vals_i("N_cen");
        pos__ = 0;
        N_cen = vals_i__[pos__++];
        context__.validate_dims("data initialization", "samp_unc", "int", context__.to_vec(N_unc));
        stan::math::validate_non_negative_index("samp_unc", "N_unc", N_unc);
        samp_unc = std::vector<int>(N_unc,int(0));
        vals_i__ = context__.vals_i("samp_unc");
        pos__ = 0;
        size_t samp_unc_limit_0__ = N_unc;
        for (size_t i_0__ = 0; i_0__ < samp_unc_limit_0__; ++i_0__) {
            samp_unc[i_0__] = vals_i__[pos__++];
        }
        context__.validate_dims("data initialization", "samp_cen", "int", context__.to_vec(N_cen));
        stan::math::validate_non_negative_index("samp_cen", "N_cen", N_cen);
        samp_cen = std::vector<int>(N_cen,int(0));
        vals_i__ = context__.vals_i("samp_cen");
        pos__ = 0;
        size_t samp_cen_limit_0__ = N_cen;
        for (size_t i_0__ = 0; i_0__ < samp_cen_limit_0__; ++i_0__) {
            samp_cen[i_0__] = vals_i__[pos__++];
        }
        context__.validate_dims("data initialization", "dur_unc", "double", context__.to_vec(N_unc));
        stan::math::validate_non_negative_index("dur_unc", "N_unc", N_unc);
        dur_unc = std::vector<double>(N_unc,double(0));
        vals_r__ = context__.vals_r("dur_unc");
        pos__ = 0;
        size_t dur_unc_limit_0__ = N_unc;
        for (size_t i_0__ = 0; i_0__ < dur_unc_limit_0__; ++i_0__) {
            dur_unc[i_0__] = vals_r__[pos__++];
        }
        context__.validate_dims("data initialization", "group_unc", "int", context__.to_vec(N_unc));
        stan::math::validate_non_negative_index("group_unc", "N_unc", N_unc);
        group_unc = std::vector<int>(N_unc,int(0));
        vals_i__ = context__.vals_i("group_unc");
        pos__ = 0;
        size_t group_unc_limit_0__ = N_unc;
        for (size_t i_0__ = 0; i_0__ < group_unc_limit_0__; ++i_0__) {
            group_unc[i_0__] = vals_i__[pos__++];
        }
        context__.validate_dims("data initialization", "cohort_unc", "int", context__.to_vec(N_unc));
        stan::math::validate_non_negative_index("cohort_unc", "N_unc", N_unc);
        cohort_unc = std::vector<int>(N_unc,int(0));
        vals_i__ = context__.vals_i("cohort_unc");
        pos__ = 0;
        size_t cohort_unc_limit_0__ = N_unc;
        for (size_t i_0__ = 0; i_0__ < cohort_unc_limit_0__; ++i_0__) {
            cohort_unc[i_0__] = vals_i__[pos__++];
        }
        context__.validate_dims("data initialization", "dur_cen", "double", context__.to_vec(N_cen));
        stan::math::validate_non_negative_index("dur_cen", "N_cen", N_cen);
        dur_cen = std::vector<double>(N_cen,double(0));
        vals_r__ = context__.vals_r("dur_cen");
        pos__ = 0;
        size_t dur_cen_limit_0__ = N_cen;
        for (size_t i_0__ = 0; i_0__ < dur_cen_limit_0__; ++i_0__) {
            dur_cen[i_0__] = vals_r__[pos__++];
        }
        context__.validate_dims("data initialization", "group_cen", "int", context__.to_vec(N_cen));
        stan::math::validate_non_negative_index("group_cen", "N_cen", N_cen);
        group_cen = std::vector<int>(N_cen,int(0));
        vals_i__ = context__.vals_i("group_cen");
        pos__ = 0;
        size_t group_cen_limit_0__ = N_cen;
        for (size_t i_0__ = 0; i_0__ < group_cen_limit_0__; ++i_0__) {
            group_cen[i_0__] = vals_i__[pos__++];
        }
        context__.validate_dims("data initialization", "cohort_cen", "int", context__.to_vec(N_cen));
        stan::math::validate_non_negative_index("cohort_cen", "N_cen", N_cen);
        cohort_cen = std::vector<int>(N_cen,int(0));
        vals_i__ = context__.vals_i("cohort_cen");
        pos__ = 0;
        size_t cohort_cen_limit_0__ = N_cen;
        for (size_t i_0__ = 0; i_0__ < cohort_cen_limit_0__; ++i_0__) {
            cohort_cen[i_0__] = vals_i__[pos__++];
        }
        context__.validate_dims("data initialization", "regime", "int", context__.to_vec(O));
        stan::math::validate_non_negative_index("regime", "O", O);
        regime = std::vector<int>(O,int(0));
        vals_i__ = context__.vals_i("regime");
        pos__ = 0;
        size_t regime_limit_0__ = O;
        for (size_t i_0__ = 0; i_0__ < regime_limit_0__; ++i_0__) {
            regime[i_0__] = vals_i__[pos__++];
        }
        context__.validate_dims("data initialization", "fauna", "int", context__.to_vec(C));
        stan::math::validate_non_negative_index("fauna", "C", C);
        fauna = std::vector<int>(C,int(0));
        vals_i__ = context__.vals_i("fauna");
        pos__ = 0;
        size_t fauna_limit_0__ = C;
        for (size_t i_0__ = 0; i_0__ < fauna_limit_0__; ++i_0__) {
            fauna[i_0__] = vals_i__[pos__++];
        }

        // validate data
        for (int k0__ = 0; k0__ < N_unc; ++k0__) {
            try { 
                check_greater_or_equal(function__,dur_unc[k0__],0,"dur_unc[k0__]", (double *)0);
            } catch (const std::exception& e) { 
                throw std::domain_error(std::string("Invalid value of dur_unc: ") + std::string(e.what()));
            };
        }
        for (int k0__ = 0; k0__ < N_cen; ++k0__) {
            try { 
                check_greater_or_equal(function__,dur_cen[k0__],0,"dur_cen[k0__]", (double *)0);
            } catch (const std::exception& e) { 
                throw std::domain_error(std::string("Invalid value of dur_cen: ") + std::string(e.what()));
            };
        }


        // validate transformed data

        // set parameter ranges
        num_params_r__ = 0U;
        param_ranges_i__.clear();
        ++num_params_r__;
        ++num_params_r__;
        num_params_r__ += C;
        ++num_params_r__;
        num_params_r__ += F;
        ++num_params_r__;
        num_params_r__ += O;
        ++num_params_r__;
        num_params_r__ += R;
        ++num_params_r__;
    }

    ~fauna_surv_model_model() { }


    void transform_inits(const stan::io::var_context& context__,
                         std::vector<int>& params_i__,
                         std::vector<double>& params_r__) const {
        stan::io::writer<double> writer__(params_r__,params_i__);
        size_t pos__;
        (void) pos__; // dummy call to supress warning
        std::vector<double> vals_r__;
        std::vector<int> vals_i__;


        if (!(context__.contains_r("alpha")))
            throw std::runtime_error("variable alpha missing");
        vals_r__ = context__.vals_r("alpha");
        pos__ = 0U;
        context__.validate_dims("initialization", "alpha", "double", context__.to_vec());
        double alpha(0);
        alpha = vals_r__[pos__++];
        try { writer__.scalar_lb_unconstrain(0,alpha); } catch (const std::exception& e) {  throw std::runtime_error(std::string("Error transforming variable alpha: ") + e.what()); }

        if (!(context__.contains_r("intercept")))
            throw std::runtime_error("variable intercept missing");
        vals_r__ = context__.vals_r("intercept");
        pos__ = 0U;
        context__.validate_dims("initialization", "intercept", "double", context__.to_vec());
        double intercept(0);
        intercept = vals_r__[pos__++];
        try { writer__.scalar_unconstrain(intercept); } catch (const std::exception& e) {  throw std::runtime_error(std::string("Error transforming variable intercept: ") + e.what()); }

        if (!(context__.contains_r("group")))
            throw std::runtime_error("variable group missing");
        vals_r__ = context__.vals_r("group");
        pos__ = 0U;
        context__.validate_dims("initialization", "group", "double", context__.to_vec(C));
        std::vector<double> group(C,double(0));
        for (int i0__ = 0U; i0__ < C; ++i0__)
            group[i0__] = vals_r__[pos__++];
        for (int i0__ = 0U; i0__ < C; ++i0__)
            try { writer__.scalar_unconstrain(group[i0__]); } catch (const std::exception& e) {  throw std::runtime_error(std::string("Error transforming variable group: ") + e.what()); }

        if (!(context__.contains_r("sigma_group")))
            throw std::runtime_error("variable sigma_group missing");
        vals_r__ = context__.vals_r("sigma_group");
        pos__ = 0U;
        context__.validate_dims("initialization", "sigma_group", "double", context__.to_vec());
        double sigma_group(0);
        sigma_group = vals_r__[pos__++];
        try { writer__.scalar_lb_unconstrain(0,sigma_group); } catch (const std::exception& e) {  throw std::runtime_error(std::string("Error transforming variable sigma_group: ") + e.what()); }

        if (!(context__.contains_r("group_mu")))
            throw std::runtime_error("variable group_mu missing");
        vals_r__ = context__.vals_r("group_mu");
        pos__ = 0U;
        context__.validate_dims("initialization", "group_mu", "double", context__.to_vec(F));
        std::vector<double> group_mu(F,double(0));
        for (int i0__ = 0U; i0__ < F; ++i0__)
            group_mu[i0__] = vals_r__[pos__++];
        for (int i0__ = 0U; i0__ < F; ++i0__)
            try { writer__.scalar_unconstrain(group_mu[i0__]); } catch (const std::exception& e) {  throw std::runtime_error(std::string("Error transforming variable group_mu: ") + e.what()); }

        if (!(context__.contains_r("sigma_fauna")))
            throw std::runtime_error("variable sigma_fauna missing");
        vals_r__ = context__.vals_r("sigma_fauna");
        pos__ = 0U;
        context__.validate_dims("initialization", "sigma_fauna", "double", context__.to_vec());
        double sigma_fauna(0);
        sigma_fauna = vals_r__[pos__++];
        try { writer__.scalar_lb_unconstrain(0,sigma_fauna); } catch (const std::exception& e) {  throw std::runtime_error(std::string("Error transforming variable sigma_fauna: ") + e.what()); }

        if (!(context__.contains_r("cohort")))
            throw std::runtime_error("variable cohort missing");
        vals_r__ = context__.vals_r("cohort");
        pos__ = 0U;
        context__.validate_dims("initialization", "cohort", "double", context__.to_vec(O));
        std::vector<double> cohort(O,double(0));
        for (int i0__ = 0U; i0__ < O; ++i0__)
            cohort[i0__] = vals_r__[pos__++];
        for (int i0__ = 0U; i0__ < O; ++i0__)
            try { writer__.scalar_unconstrain(cohort[i0__]); } catch (const std::exception& e) {  throw std::runtime_error(std::string("Error transforming variable cohort: ") + e.what()); }

        if (!(context__.contains_r("sigma_cohort")))
            throw std::runtime_error("variable sigma_cohort missing");
        vals_r__ = context__.vals_r("sigma_cohort");
        pos__ = 0U;
        context__.validate_dims("initialization", "sigma_cohort", "double", context__.to_vec());
        double sigma_cohort(0);
        sigma_cohort = vals_r__[pos__++];
        try { writer__.scalar_lb_unconstrain(0,sigma_cohort); } catch (const std::exception& e) {  throw std::runtime_error(std::string("Error transforming variable sigma_cohort: ") + e.what()); }

        if (!(context__.contains_r("cohort_mu")))
            throw std::runtime_error("variable cohort_mu missing");
        vals_r__ = context__.vals_r("cohort_mu");
        pos__ = 0U;
        context__.validate_dims("initialization", "cohort_mu", "double", context__.to_vec(R));
        std::vector<double> cohort_mu(R,double(0));
        for (int i0__ = 0U; i0__ < R; ++i0__)
            cohort_mu[i0__] = vals_r__[pos__++];
        for (int i0__ = 0U; i0__ < R; ++i0__)
            try { writer__.scalar_unconstrain(cohort_mu[i0__]); } catch (const std::exception& e) {  throw std::runtime_error(std::string("Error transforming variable cohort_mu: ") + e.what()); }

        if (!(context__.contains_r("sigma_regime")))
            throw std::runtime_error("variable sigma_regime missing");
        vals_r__ = context__.vals_r("sigma_regime");
        pos__ = 0U;
        context__.validate_dims("initialization", "sigma_regime", "double", context__.to_vec());
        double sigma_regime(0);
        sigma_regime = vals_r__[pos__++];
        try { writer__.scalar_lb_unconstrain(0,sigma_regime); } catch (const std::exception& e) {  throw std::runtime_error(std::string("Error transforming variable sigma_regime: ") + e.what()); }
        params_r__ = writer__.data_r();
        params_i__ = writer__.data_i();
    }

    void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double,Eigen::Dynamic,1>& params_r) const {
      std::vector<double> params_r_vec;
      std::vector<int> params_i_vec;
      transform_inits(context, params_i_vec, params_r_vec);
      params_r.resize(params_r_vec.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r(i) = params_r_vec[i];
    }


    template <bool propto__, bool jacobian__, typename T__>
    T__ log_prob(vector<T__>& params_r__,
                 vector<int>& params_i__,
                 std::ostream* pstream__ = 0) const {

        T__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        T__ lp__(0.0);
        stan::math::accumulator<T__> lp_accum__;

        // model parameters
        stan::io::reader<T__> in__(params_r__,params_i__);

        T__ alpha;
        (void) alpha;   // dummy to suppress unused var warning
        if (jacobian__)
            alpha = in__.scalar_lb_constrain(0,lp__);
        else
            alpha = in__.scalar_lb_constrain(0);

        T__ intercept;
        (void) intercept;   // dummy to suppress unused var warning
        if (jacobian__)
            intercept = in__.scalar_constrain(lp__);
        else
            intercept = in__.scalar_constrain();

        vector<T__> group;
        size_t dim_group_0__ = C;
        group.reserve(dim_group_0__);
        for (size_t k_0__ = 0; k_0__ < dim_group_0__; ++k_0__) {
            if (jacobian__)
                group.push_back(in__.scalar_constrain(lp__));
            else
                group.push_back(in__.scalar_constrain());
        }

        T__ sigma_group;
        (void) sigma_group;   // dummy to suppress unused var warning
        if (jacobian__)
            sigma_group = in__.scalar_lb_constrain(0,lp__);
        else
            sigma_group = in__.scalar_lb_constrain(0);

        vector<T__> group_mu;
        size_t dim_group_mu_0__ = F;
        group_mu.reserve(dim_group_mu_0__);
        for (size_t k_0__ = 0; k_0__ < dim_group_mu_0__; ++k_0__) {
            if (jacobian__)
                group_mu.push_back(in__.scalar_constrain(lp__));
            else
                group_mu.push_back(in__.scalar_constrain());
        }

        T__ sigma_fauna;
        (void) sigma_fauna;   // dummy to suppress unused var warning
        if (jacobian__)
            sigma_fauna = in__.scalar_lb_constrain(0,lp__);
        else
            sigma_fauna = in__.scalar_lb_constrain(0);

        vector<T__> cohort;
        size_t dim_cohort_0__ = O;
        cohort.reserve(dim_cohort_0__);
        for (size_t k_0__ = 0; k_0__ < dim_cohort_0__; ++k_0__) {
            if (jacobian__)
                cohort.push_back(in__.scalar_constrain(lp__));
            else
                cohort.push_back(in__.scalar_constrain());
        }

        T__ sigma_cohort;
        (void) sigma_cohort;   // dummy to suppress unused var warning
        if (jacobian__)
            sigma_cohort = in__.scalar_lb_constrain(0,lp__);
        else
            sigma_cohort = in__.scalar_lb_constrain(0);

        vector<T__> cohort_mu;
        size_t dim_cohort_mu_0__ = R;
        cohort_mu.reserve(dim_cohort_mu_0__);
        for (size_t k_0__ = 0; k_0__ < dim_cohort_mu_0__; ++k_0__) {
            if (jacobian__)
                cohort_mu.push_back(in__.scalar_constrain(lp__));
            else
                cohort_mu.push_back(in__.scalar_constrain());
        }

        T__ sigma_regime;
        (void) sigma_regime;   // dummy to suppress unused var warning
        if (jacobian__)
            sigma_regime = in__.scalar_lb_constrain(0,lp__);
        else
            sigma_regime = in__.scalar_lb_constrain(0);


        // transformed parameters

        // initialized transformed params to avoid seg fault on val access


        // validate transformed parameters

        const char* function__ = "validate transformed params %1%";
        (void) function__; // dummy to suppress unused var warning
        // model body
        lp_accum__.add(cauchy_log<propto__>(alpha, 0, 2.5));
        lp_accum__.add(normal_log<propto__>(intercept, 0, 10));
        for (int c = 1; c <= C; ++c) {
            lp_accum__.add(normal_log<propto__>(get_base1(group,c,"group",1), get_base1(group_mu,get_base1(fauna,c,"fauna",1),"group_mu",1), sigma_group));
        }
        lp_accum__.add(cauchy_log<propto__>(sigma_group, 0, 2.5));
        for (int f = 1; f <= F; ++f) {
            lp_accum__.add(normal_log<propto__>(get_base1(group_mu,f,"group_mu",1), 0, sigma_fauna));
        }
        lp_accum__.add(cauchy_log<propto__>(sigma_fauna, 0, 2.5));
        for (int o = 1; o <= O; ++o) {
            lp_accum__.add(normal_log<propto__>(get_base1(cohort,o,"cohort",1), get_base1(cohort_mu,get_base1(regime,o,"regime",1),"cohort_mu",1), sigma_cohort));
        }
        lp_accum__.add(cauchy_log<propto__>(sigma_cohort, 0, 2.5));
        for (int r = 1; r <= R; ++r) {
            lp_accum__.add(normal_log<propto__>(get_base1(cohort_mu,r,"cohort_mu",1), 0, sigma_regime));
        }
        lp_accum__.add(cauchy_log<propto__>(sigma_regime, 0, 2.5));
        for (int i = 1; i <= N_unc; ++i) {
            if (as_bool(logical_eq(get_base1(dur_unc,i,"dur_unc",1),1))) {
                lp_accum__.add(weibull_cdf_log(get_base1(dur_unc,i,"dur_unc",1),alpha,exp((-(((intercept + get_base1(group,get_base1(group_unc,i,"group_unc",1),"group",1)) + get_base1(cohort,get_base1(cohort_unc,i,"cohort_unc",1),"cohort",1))) / alpha))));
            } else {
                lp_accum__.add(weibull_log(get_base1(dur_unc,i,"dur_unc",1),alpha,exp((-(((intercept + get_base1(group,get_base1(group_unc,i,"group_unc",1),"group",1)) + get_base1(cohort,get_base1(cohort_unc,i,"cohort_unc",1),"cohort",1))) / alpha))));
            }
        }
        for (int i = 1; i <= N_cen; ++i) {
            lp_accum__.add(weibull_ccdf_log(get_base1(dur_cen,i,"dur_cen",1),alpha,exp((-(((intercept + get_base1(group,get_base1(group_cen,i,"group_cen",1),"group",1)) + get_base1(cohort,get_base1(cohort_cen,i,"cohort_cen",1),"cohort",1))) / alpha))));
        }

        lp_accum__.add(lp__);
        return lp_accum__.sum();

    } // log_prob()

    template <bool propto, bool jacobian, typename T_>
    T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
               std::ostream* pstream = 0) const {
      std::vector<T_> vec_params_r;
      vec_params_r.reserve(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        vec_params_r.push_back(params_r(i));
      std::vector<int> vec_params_i;
      return log_prob<propto,jacobian,T_>(vec_params_r, vec_params_i, pstream);
    }


    void get_param_names(std::vector<std::string>& names__) const {
        names__.resize(0);
        names__.push_back("alpha");
        names__.push_back("intercept");
        names__.push_back("group");
        names__.push_back("sigma_group");
        names__.push_back("group_mu");
        names__.push_back("sigma_fauna");
        names__.push_back("cohort");
        names__.push_back("sigma_cohort");
        names__.push_back("cohort_mu");
        names__.push_back("sigma_regime");
    }


    void get_dims(std::vector<std::vector<size_t> >& dimss__) const {
        dimss__.resize(0);
        std::vector<size_t> dims__;
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(C);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(F);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(O);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(R);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
    }

    template <typename RNG>
    void write_array(RNG& base_rng__,
                     std::vector<double>& params_r__,
                     std::vector<int>& params_i__,
                     std::vector<double>& vars__,
                     bool include_tparams__ = true,
                     bool include_gqs__ = true,
                     std::ostream* pstream__ = 0) const {
        vars__.resize(0);
        stan::io::reader<double> in__(params_r__,params_i__);
        static const char* function__ = "fauna_surv_model_model_namespace::write_array(%1%)";
        (void) function__; // dummy call to supress warning
        // read-transform, write parameters
        double alpha = in__.scalar_lb_constrain(0);
        double intercept = in__.scalar_constrain();
        vector<double> group;
        size_t dim_group_0__ = C;
        for (size_t k_0__ = 0; k_0__ < dim_group_0__; ++k_0__) {
            group.push_back(in__.scalar_constrain());
        }
        double sigma_group = in__.scalar_lb_constrain(0);
        vector<double> group_mu;
        size_t dim_group_mu_0__ = F;
        for (size_t k_0__ = 0; k_0__ < dim_group_mu_0__; ++k_0__) {
            group_mu.push_back(in__.scalar_constrain());
        }
        double sigma_fauna = in__.scalar_lb_constrain(0);
        vector<double> cohort;
        size_t dim_cohort_0__ = O;
        for (size_t k_0__ = 0; k_0__ < dim_cohort_0__; ++k_0__) {
            cohort.push_back(in__.scalar_constrain());
        }
        double sigma_cohort = in__.scalar_lb_constrain(0);
        vector<double> cohort_mu;
        size_t dim_cohort_mu_0__ = R;
        for (size_t k_0__ = 0; k_0__ < dim_cohort_mu_0__; ++k_0__) {
            cohort_mu.push_back(in__.scalar_constrain());
        }
        double sigma_regime = in__.scalar_lb_constrain(0);
        vars__.push_back(alpha);
        vars__.push_back(intercept);
        for (int k_0__ = 0; k_0__ < C; ++k_0__) {
            vars__.push_back(group[k_0__]);
        }
        vars__.push_back(sigma_group);
        for (int k_0__ = 0; k_0__ < F; ++k_0__) {
            vars__.push_back(group_mu[k_0__]);
        }
        vars__.push_back(sigma_fauna);
        for (int k_0__ = 0; k_0__ < O; ++k_0__) {
            vars__.push_back(cohort[k_0__]);
        }
        vars__.push_back(sigma_cohort);
        for (int k_0__ = 0; k_0__ < R; ++k_0__) {
            vars__.push_back(cohort_mu[k_0__]);
        }
        vars__.push_back(sigma_regime);

        if (!include_tparams__) return;
        // declare and define transformed parameters
        double lp__ = 0.0;
        (void) lp__; // dummy call to supress warning
        stan::math::accumulator<double> lp_accum__;



        // validate transformed parameters

        // write transformed parameters

        if (!include_gqs__) return;
        // declare and define generated quantities


        // validate generated quantities

        // write generated quantities
    }

    template <typename RNG>
    void write_array(RNG& base_rng,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                     bool include_tparams = true,
                     bool include_gqs = true,
                     std::ostream* pstream = 0) const {
      std::vector<double> params_r_vec(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r_vec[i] = params_r(i);
      std::vector<double> vars_vec;
      std::vector<int> params_i_vec;
      write_array(base_rng,params_r_vec,params_i_vec,vars_vec,include_tparams,include_gqs,pstream);
      vars.resize(vars_vec.size());
      for (int i = 0; i < vars.size(); ++i)
        vars(i) = vars_vec[i];
    }


    void write_csv_header(std::ostream& o__) const {
        stan::io::csv_writer writer__(o__);
        writer__.comma();
        o__ << "alpha";
        writer__.comma();
        o__ << "intercept";
        for (int k_0__ = 1; k_0__ <= C; ++k_0__) {
            writer__.comma();
            o__ << "group" << '.' << k_0__;
        }
        writer__.comma();
        o__ << "sigma_group";
        for (int k_0__ = 1; k_0__ <= F; ++k_0__) {
            writer__.comma();
            o__ << "group_mu" << '.' << k_0__;
        }
        writer__.comma();
        o__ << "sigma_fauna";
        for (int k_0__ = 1; k_0__ <= O; ++k_0__) {
            writer__.comma();
            o__ << "cohort" << '.' << k_0__;
        }
        writer__.comma();
        o__ << "sigma_cohort";
        for (int k_0__ = 1; k_0__ <= R; ++k_0__) {
            writer__.comma();
            o__ << "cohort_mu" << '.' << k_0__;
        }
        writer__.comma();
        o__ << "sigma_regime";
        writer__.newline();
    }

    template <typename RNG>
    void write_csv(RNG& base_rng__,
                   std::vector<double>& params_r__,
                   std::vector<int>& params_i__,
                   std::ostream& o__,
                   std::ostream* pstream__ = 0) const {
        stan::io::reader<double> in__(params_r__,params_i__);
        stan::io::csv_writer writer__(o__);
        static const char* function__ = "fauna_surv_model_model_namespace::write_csv(%1%)";
        (void) function__; // dummy call to supress warning
        // read-transform, write parameters
        double alpha = in__.scalar_lb_constrain(0);
        writer__.write(alpha);
        double intercept = in__.scalar_constrain();
        writer__.write(intercept);
        vector<double> group;
        size_t dim_group_0__ = C;
        for (size_t k_0__ = 0; k_0__ < dim_group_0__; ++k_0__) {
            group.push_back(in__.scalar_constrain());
            writer__.write(group[k_0__]);
        }
        double sigma_group = in__.scalar_lb_constrain(0);
        writer__.write(sigma_group);
        vector<double> group_mu;
        size_t dim_group_mu_0__ = F;
        for (size_t k_0__ = 0; k_0__ < dim_group_mu_0__; ++k_0__) {
            group_mu.push_back(in__.scalar_constrain());
            writer__.write(group_mu[k_0__]);
        }
        double sigma_fauna = in__.scalar_lb_constrain(0);
        writer__.write(sigma_fauna);
        vector<double> cohort;
        size_t dim_cohort_0__ = O;
        for (size_t k_0__ = 0; k_0__ < dim_cohort_0__; ++k_0__) {
            cohort.push_back(in__.scalar_constrain());
            writer__.write(cohort[k_0__]);
        }
        double sigma_cohort = in__.scalar_lb_constrain(0);
        writer__.write(sigma_cohort);
        vector<double> cohort_mu;
        size_t dim_cohort_mu_0__ = R;
        for (size_t k_0__ = 0; k_0__ < dim_cohort_mu_0__; ++k_0__) {
            cohort_mu.push_back(in__.scalar_constrain());
            writer__.write(cohort_mu[k_0__]);
        }
        double sigma_regime = in__.scalar_lb_constrain(0);
        writer__.write(sigma_regime);

        // declare, define and validate transformed parameters
        double lp__ = 0.0;
        (void) lp__; // dummy call to supress warning
        stan::math::accumulator<double> lp_accum__;




        // write transformed parameters

        // declare and define generated quantities


        // validate generated quantities

        // write generated quantities
        writer__.newline();
    }

    template <typename RNG>
    void write_csv(RNG& base_rng,
                   Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                   std::ostream& o,
                   std::ostream* pstream = 0) const {
      std::vector<double> params_r_vec(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r_vec[i] = params_r(i);
      std::vector<int> params_i_vec;  // dummy
      write_csv(base_rng, params_r_vec, params_i_vec, o, pstream);
    }

    static std::string model_name() {
        return "fauna_surv_model_model";
    }


    void constrained_param_names(std::vector<std::string>& param_names__,
                                 bool include_tparams__ = true,
                                 bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        param_name_stream__.str(std::string());
        param_name_stream__ << "alpha";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "intercept";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= C; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "group" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        param_name_stream__.str(std::string());
        param_name_stream__ << "sigma_group";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= F; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "group_mu" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        param_name_stream__.str(std::string());
        param_name_stream__ << "sigma_fauna";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= O; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "cohort" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        param_name_stream__.str(std::string());
        param_name_stream__ << "sigma_cohort";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= R; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "cohort_mu" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        param_name_stream__.str(std::string());
        param_name_stream__ << "sigma_regime";
        param_names__.push_back(param_name_stream__.str());

        if (!include_gqs__ && !include_tparams__) return;

        if (!include_gqs__) return;
    }


    void unconstrained_param_names(std::vector<std::string>& param_names__,
                                   bool include_tparams__ = true,
                                   bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        param_name_stream__.str(std::string());
        param_name_stream__ << "alpha";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "intercept";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= C; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "group" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        param_name_stream__.str(std::string());
        param_name_stream__ << "sigma_group";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= F; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "group_mu" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        param_name_stream__.str(std::string());
        param_name_stream__ << "sigma_fauna";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= O; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "cohort" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        param_name_stream__.str(std::string());
        param_name_stream__ << "sigma_cohort";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= R; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "cohort_mu" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        param_name_stream__.str(std::string());
        param_name_stream__ << "sigma_regime";
        param_names__.push_back(param_name_stream__.str());

        if (!include_gqs__ && !include_tparams__) return;

        if (!include_gqs__) return;
    }

}; // model

} // namespace

typedef fauna_surv_model_model_namespace::fauna_surv_model_model stan_model;

